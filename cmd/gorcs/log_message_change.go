// Generated by github.com/arran4/go-subcommand/cmd/gosubc

package main

import (
	"flag"
	"fmt"
	"os"

	"github.com/arran4/golang-rcs/internal/cli"
)

var _ Cmd = (*LogMessageChange)(nil)

type LogMessageChange struct {
	*LogMessage
	Flags    *flag.FlagSet
	revision string
	message  string
	files    []string
}

type UsageDataLogMessageChange struct {
	*LogMessageChange
	Recursive bool
}

func (c *LogMessageChange) Usage() {
	// TODO: Create usage template
	fmt.Fprintf(os.Stderr, "Usage of %s log message change:\n", os.Args[0])
	c.Flags.PrintDefaults()
}

func (c *LogMessageChange) Execute(args []string) error {
	if err := c.Flags.Parse(args); err != nil {
		return err
	}
	c.files = c.Flags.Args()
	if c.revision == "" {
		return fmt.Errorf("revision required")
	}
	// message can be empty? usually not recommended but possible.
	return cli.LogMessageChange(c.revision, c.message, c.files...)
}

func (c *LogMessage) NewLogMessageChange() *LogMessageChange {
	set := flag.NewFlagSet("change", flag.ContinueOnError)
	v := &LogMessageChange{
		LogMessage: c,
		Flags:      set,
	}
	set.StringVar(&v.revision, "rev", "", "Revision to change log message for")
	set.StringVar(&v.message, "m", "", "New log message")
	set.Usage = v.Usage
	return v
}
